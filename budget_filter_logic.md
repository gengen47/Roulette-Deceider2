# 予算帯フィルタの現状と課題・改善案

## 1. 現状の仕組み（コードベースフィルタ）
現在、ディナーモードでは以下のロジックでフィルタリングを行っています。

1. **APIリクエスト**: `budget` パラメータを指定せず、周辺店舗を最大100件取得（0件問題回避のため）。
2. **ターゲットコード算出**: ユーザーが指定した上限（例：5000円）に基づき、該当する予算コードのリストを作成。
   - 例: 上限5000円 → `["B009", "B010", ..., "B002", "B003", "B008"]`
3. **マッチング**: 取得した店舗の `budgetCode` が、リストに含まれているか判定。

### 🚨 なぜ0件になるのか（推測される原因）
現状で「上限5000円」でも0件になる場合、以下の可能性が高いです。

1. **コード不一致**: 店舗データが持つ `budgetCode` が、アプリ側で想定しているコード（マスタ定義）と異なる、または欠落している。
2. **マッピング漏れ**: アプリ側のマスタ（`BUDGETS`）に定義されていないコードが返されている（例: 新設コードや特殊コード）。

## 2. 解決策：テキスト解析ベースへの移行（推奨）
「コード」への依存をやめ、ランチモードですでに実績のある「価格テキスト解析」方式に統一することを提案します。

### 仕組み
店舗情報の **予算テキスト（例："2001～3000円"）** を直接解析して判定します。

- **ロジック**:
    1. `budget.name`（例："2001～3000円"）から最初の数値を抽出 → `2001`
    2. この数値（予算の下限に近い値）が、ユーザー指定の予算範囲内であるか判定。
    - ※上限5000円の場合、`2001 <= 5000` なのでヒット。

### メリット
- **マスタ不要**: ホットペッパーの予算コード体系が変わっても、金額の表記（数字）さえあれば動作する。
- **柔軟性**: 「〜500円」「4001〜5000円」などあらゆる表記に対して、数字さえ抽出できれば判定可能。
- **統一**: ランチとディナーで完全に同じロジックが使用でき、バグが混入しにくい。

## 3. 実装イメージ
```javascript
// ディナーモード（改良版）
// budgetCodeではなく、budget(テキスト)を解析して判定
const text = s.budget; // 例: "2001～3000円"
if (!text) return true; 

const match = text.match(/(\d{{1,3}}(?:,\d{{3}})*)/);
if (match) {{
    const price = parseInt(match[1].replace(/,/g, ''));
    // 抽出した金額（例:2001）がユーザー指定範囲内か
    return price <= strictMaxPrice && price >= strictMinPrice;
}}
```

この修正により、牛角（2001～3000円）のような店舗も確実にヒットするようになります。
